// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"family-joint-school/model"
	"family-joint-school/mysql/ent/account"
	"family-joint-school/mysql/ent/class"
	"family-joint-school/mysql/ent/homework"
	"family-joint-school/mysql/ent/notice"
	"family-joint-school/mysql/ent/predicate"
	"family-joint-school/mysql/ent/user"
	"family-joint-school/mysql/ent/userhomework"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount      = "Account"
	TypeClass        = "Class"
	TypeHomework     = "Homework"
	TypeNotice       = "Notice"
	TypeUser         = "User"
	TypeUserHomeWork = "UserHomeWork"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	user_id       *uint64
	adduser_id    *int64
	account       *string
	password      *string
	permission    *uint8
	addpermission *int8
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Account, error)
	predicates    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id uint64) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AccountMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *AccountMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccountMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *AccountMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[account.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AccountMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[account.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, account.FieldUserID)
}

// SetAccount sets the "account" field.
func (m *AccountMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ClearAccount clears the value of the "account" field.
func (m *AccountMutation) ClearAccount() {
	m.account = nil
	m.clearedFields[account.FieldAccount] = struct{}{}
}

// AccountCleared returns if the "account" field was cleared in this mutation.
func (m *AccountMutation) AccountCleared() bool {
	_, ok := m.clearedFields[account.FieldAccount]
	return ok
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountMutation) ResetAccount() {
	m.account = nil
	delete(m.clearedFields, account.FieldAccount)
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *AccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[account.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *AccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[account.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, account.FieldPassword)
}

// SetPermission sets the "permission" field.
func (m *AccountMutation) SetPermission(u uint8) {
	m.permission = &u
	m.addpermission = nil
}

// Permission returns the value of the "permission" field in the mutation.
func (m *AccountMutation) Permission() (r uint8, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPermission(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// AddPermission adds u to the "permission" field.
func (m *AccountMutation) AddPermission(u int8) {
	if m.addpermission != nil {
		*m.addpermission += u
	} else {
		m.addpermission = &u
	}
}

// AddedPermission returns the value that was added to the "permission" field in this mutation.
func (m *AccountMutation) AddedPermission() (r int8, exists bool) {
	v := m.addpermission
	if v == nil {
		return
	}
	return *v, true
}

// ClearPermission clears the value of the "permission" field.
func (m *AccountMutation) ClearPermission() {
	m.permission = nil
	m.addpermission = nil
	m.clearedFields[account.FieldPermission] = struct{}{}
}

// PermissionCleared returns if the "permission" field was cleared in this mutation.
func (m *AccountMutation) PermissionCleared() bool {
	_, ok := m.clearedFields[account.FieldPermission]
	return ok
}

// ResetPermission resets all changes to the "permission" field.
func (m *AccountMutation) ResetPermission() {
	m.permission = nil
	m.addpermission = nil
	delete(m.clearedFields, account.FieldPermission)
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AccountMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[account.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AccountMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, account.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AccountMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[account.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AccountMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, account.FieldUpdatedAt)
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.account != nil {
		fields = append(fields, account.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.permission != nil {
		fields = append(fields, account.FieldPermission)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.UserID()
	case account.FieldAccount:
		return m.Account()
	case account.FieldPassword:
		return m.Password()
	case account.FieldPermission:
		return m.Permission()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldUserID:
		return m.OldUserID(ctx)
	case account.FieldAccount:
		return m.OldAccount(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldPermission:
		return m.OldPermission(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case account.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldPermission:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.addpermission != nil {
		fields = append(fields, account.FieldPermission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.AddedUserID()
	case account.FieldPermission:
		return m.AddedPermission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case account.FieldPermission:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPermission(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldUserID) {
		fields = append(fields, account.FieldUserID)
	}
	if m.FieldCleared(account.FieldAccount) {
		fields = append(fields, account.FieldAccount)
	}
	if m.FieldCleared(account.FieldPassword) {
		fields = append(fields, account.FieldPassword)
	}
	if m.FieldCleared(account.FieldPermission) {
		fields = append(fields, account.FieldPermission)
	}
	if m.FieldCleared(account.FieldCreatedAt) {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.FieldCleared(account.FieldUpdatedAt) {
		fields = append(fields, account.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldUserID:
		m.ClearUserID()
		return nil
	case account.FieldAccount:
		m.ClearAccount()
		return nil
	case account.FieldPassword:
		m.ClearPassword()
		return nil
	case account.FieldPermission:
		m.ClearPermission()
		return nil
	case account.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldUserID:
		m.ResetUserID()
		return nil
	case account.FieldAccount:
		m.ResetAccount()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldPermission:
		m.ResetPermission()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	name          *string
	extra         *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Class, error)
	predicates    []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id uint64) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Class entities.
func (m *ClassMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ClassMutation) ClearName() {
	m.name = nil
	m.clearedFields[class.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ClassMutation) NameCleared() bool {
	_, ok := m.clearedFields[class.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ClassMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, class.FieldName)
}

// SetExtra sets the "extra" field.
func (m *ClassMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *ClassMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *ClassMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[class.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *ClassMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[class.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *ClassMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, class.FieldExtra)
}

// SetCreatedAt sets the "created_at" field.
func (m *ClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ClassMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[class.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ClassMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[class.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClassMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, class.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ClassMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[class.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ClassMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[class.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, class.FieldUpdatedAt)
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, class.FieldName)
	}
	if m.extra != nil {
		fields = append(fields, class.FieldExtra)
	}
	if m.created_at != nil {
		fields = append(fields, class.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, class.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldName:
		return m.Name()
	case class.FieldExtra:
		return m.Extra()
	case class.FieldCreatedAt:
		return m.CreatedAt()
	case class.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldName:
		return m.OldName(ctx)
	case class.FieldExtra:
		return m.OldExtra(ctx)
	case class.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case class.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case class.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case class.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case class.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(class.FieldName) {
		fields = append(fields, class.FieldName)
	}
	if m.FieldCleared(class.FieldExtra) {
		fields = append(fields, class.FieldExtra)
	}
	if m.FieldCleared(class.FieldCreatedAt) {
		fields = append(fields, class.FieldCreatedAt)
	}
	if m.FieldCleared(class.FieldUpdatedAt) {
		fields = append(fields, class.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	switch name {
	case class.FieldName:
		m.ClearName()
		return nil
	case class.FieldExtra:
		m.ClearExtra()
		return nil
	case class.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case class.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldName:
		m.ResetName()
		return nil
	case class.FieldExtra:
		m.ResetExtra()
		return nil
	case class.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case class.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Class edge %s", name)
}

// HomeworkMutation represents an operation that mutates the Homework nodes in the graph.
type HomeworkMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	title         *string
	content       *string
	pics          *[]model.Pic
	class_id      *uint8
	addclass_id   *int8
	class_name    *string
	teacher_id    *uint8
	addteacher_id *int8
	extra         *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Homework, error)
	predicates    []predicate.Homework
}

var _ ent.Mutation = (*HomeworkMutation)(nil)

// homeworkOption allows management of the mutation configuration using functional options.
type homeworkOption func(*HomeworkMutation)

// newHomeworkMutation creates new mutation for the Homework entity.
func newHomeworkMutation(c config, op Op, opts ...homeworkOption) *HomeworkMutation {
	m := &HomeworkMutation{
		config:        c,
		op:            op,
		typ:           TypeHomework,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHomeworkID sets the ID field of the mutation.
func withHomeworkID(id uint64) homeworkOption {
	return func(m *HomeworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Homework
		)
		m.oldValue = func(ctx context.Context) (*Homework, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Homework.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHomework sets the old Homework of the mutation.
func withHomework(node *Homework) homeworkOption {
	return func(m *HomeworkMutation) {
		m.oldValue = func(context.Context) (*Homework, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HomeworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HomeworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Homework entities.
func (m *HomeworkMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HomeworkMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HomeworkMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Homework.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *HomeworkMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *HomeworkMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *HomeworkMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[homework.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *HomeworkMutation) TitleCleared() bool {
	_, ok := m.clearedFields[homework.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *HomeworkMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, homework.FieldTitle)
}

// SetContent sets the "content" field.
func (m *HomeworkMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *HomeworkMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *HomeworkMutation) ClearContent() {
	m.content = nil
	m.clearedFields[homework.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *HomeworkMutation) ContentCleared() bool {
	_, ok := m.clearedFields[homework.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *HomeworkMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, homework.FieldContent)
}

// SetPics sets the "pics" field.
func (m *HomeworkMutation) SetPics(value []model.Pic) {
	m.pics = &value
}

// Pics returns the value of the "pics" field in the mutation.
func (m *HomeworkMutation) Pics() (r []model.Pic, exists bool) {
	v := m.pics
	if v == nil {
		return
	}
	return *v, true
}

// OldPics returns the old "pics" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldPics(ctx context.Context) (v []model.Pic, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPics: %w", err)
	}
	return oldValue.Pics, nil
}

// ClearPics clears the value of the "pics" field.
func (m *HomeworkMutation) ClearPics() {
	m.pics = nil
	m.clearedFields[homework.FieldPics] = struct{}{}
}

// PicsCleared returns if the "pics" field was cleared in this mutation.
func (m *HomeworkMutation) PicsCleared() bool {
	_, ok := m.clearedFields[homework.FieldPics]
	return ok
}

// ResetPics resets all changes to the "pics" field.
func (m *HomeworkMutation) ResetPics() {
	m.pics = nil
	delete(m.clearedFields, homework.FieldPics)
}

// SetClassID sets the "class_id" field.
func (m *HomeworkMutation) SetClassID(u uint8) {
	m.class_id = &u
	m.addclass_id = nil
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *HomeworkMutation) ClassID() (r uint8, exists bool) {
	v := m.class_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldClassID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// AddClassID adds u to the "class_id" field.
func (m *HomeworkMutation) AddClassID(u int8) {
	if m.addclass_id != nil {
		*m.addclass_id += u
	} else {
		m.addclass_id = &u
	}
}

// AddedClassID returns the value that was added to the "class_id" field in this mutation.
func (m *HomeworkMutation) AddedClassID() (r int8, exists bool) {
	v := m.addclass_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearClassID clears the value of the "class_id" field.
func (m *HomeworkMutation) ClearClassID() {
	m.class_id = nil
	m.addclass_id = nil
	m.clearedFields[homework.FieldClassID] = struct{}{}
}

// ClassIDCleared returns if the "class_id" field was cleared in this mutation.
func (m *HomeworkMutation) ClassIDCleared() bool {
	_, ok := m.clearedFields[homework.FieldClassID]
	return ok
}

// ResetClassID resets all changes to the "class_id" field.
func (m *HomeworkMutation) ResetClassID() {
	m.class_id = nil
	m.addclass_id = nil
	delete(m.clearedFields, homework.FieldClassID)
}

// SetClassName sets the "class_name" field.
func (m *HomeworkMutation) SetClassName(s string) {
	m.class_name = &s
}

// ClassName returns the value of the "class_name" field in the mutation.
func (m *HomeworkMutation) ClassName() (r string, exists bool) {
	v := m.class_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClassName returns the old "class_name" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldClassName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassName: %w", err)
	}
	return oldValue.ClassName, nil
}

// ClearClassName clears the value of the "class_name" field.
func (m *HomeworkMutation) ClearClassName() {
	m.class_name = nil
	m.clearedFields[homework.FieldClassName] = struct{}{}
}

// ClassNameCleared returns if the "class_name" field was cleared in this mutation.
func (m *HomeworkMutation) ClassNameCleared() bool {
	_, ok := m.clearedFields[homework.FieldClassName]
	return ok
}

// ResetClassName resets all changes to the "class_name" field.
func (m *HomeworkMutation) ResetClassName() {
	m.class_name = nil
	delete(m.clearedFields, homework.FieldClassName)
}

// SetTeacherID sets the "teacher_id" field.
func (m *HomeworkMutation) SetTeacherID(u uint8) {
	m.teacher_id = &u
	m.addteacher_id = nil
}

// TeacherID returns the value of the "teacher_id" field in the mutation.
func (m *HomeworkMutation) TeacherID() (r uint8, exists bool) {
	v := m.teacher_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTeacherID returns the old "teacher_id" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldTeacherID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeacherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeacherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeacherID: %w", err)
	}
	return oldValue.TeacherID, nil
}

// AddTeacherID adds u to the "teacher_id" field.
func (m *HomeworkMutation) AddTeacherID(u int8) {
	if m.addteacher_id != nil {
		*m.addteacher_id += u
	} else {
		m.addteacher_id = &u
	}
}

// AddedTeacherID returns the value that was added to the "teacher_id" field in this mutation.
func (m *HomeworkMutation) AddedTeacherID() (r int8, exists bool) {
	v := m.addteacher_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTeacherID clears the value of the "teacher_id" field.
func (m *HomeworkMutation) ClearTeacherID() {
	m.teacher_id = nil
	m.addteacher_id = nil
	m.clearedFields[homework.FieldTeacherID] = struct{}{}
}

// TeacherIDCleared returns if the "teacher_id" field was cleared in this mutation.
func (m *HomeworkMutation) TeacherIDCleared() bool {
	_, ok := m.clearedFields[homework.FieldTeacherID]
	return ok
}

// ResetTeacherID resets all changes to the "teacher_id" field.
func (m *HomeworkMutation) ResetTeacherID() {
	m.teacher_id = nil
	m.addteacher_id = nil
	delete(m.clearedFields, homework.FieldTeacherID)
}

// SetExtra sets the "extra" field.
func (m *HomeworkMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *HomeworkMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *HomeworkMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[homework.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *HomeworkMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[homework.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *HomeworkMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, homework.FieldExtra)
}

// SetCreatedAt sets the "created_at" field.
func (m *HomeworkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HomeworkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HomeworkMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[homework.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HomeworkMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[homework.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HomeworkMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, homework.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HomeworkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HomeworkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Homework entity.
// If the Homework object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeworkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HomeworkMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[homework.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HomeworkMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[homework.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HomeworkMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, homework.FieldUpdatedAt)
}

// Where appends a list predicates to the HomeworkMutation builder.
func (m *HomeworkMutation) Where(ps ...predicate.Homework) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HomeworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Homework).
func (m *HomeworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HomeworkMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.title != nil {
		fields = append(fields, homework.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, homework.FieldContent)
	}
	if m.pics != nil {
		fields = append(fields, homework.FieldPics)
	}
	if m.class_id != nil {
		fields = append(fields, homework.FieldClassID)
	}
	if m.class_name != nil {
		fields = append(fields, homework.FieldClassName)
	}
	if m.teacher_id != nil {
		fields = append(fields, homework.FieldTeacherID)
	}
	if m.extra != nil {
		fields = append(fields, homework.FieldExtra)
	}
	if m.created_at != nil {
		fields = append(fields, homework.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, homework.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HomeworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case homework.FieldTitle:
		return m.Title()
	case homework.FieldContent:
		return m.Content()
	case homework.FieldPics:
		return m.Pics()
	case homework.FieldClassID:
		return m.ClassID()
	case homework.FieldClassName:
		return m.ClassName()
	case homework.FieldTeacherID:
		return m.TeacherID()
	case homework.FieldExtra:
		return m.Extra()
	case homework.FieldCreatedAt:
		return m.CreatedAt()
	case homework.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HomeworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case homework.FieldTitle:
		return m.OldTitle(ctx)
	case homework.FieldContent:
		return m.OldContent(ctx)
	case homework.FieldPics:
		return m.OldPics(ctx)
	case homework.FieldClassID:
		return m.OldClassID(ctx)
	case homework.FieldClassName:
		return m.OldClassName(ctx)
	case homework.FieldTeacherID:
		return m.OldTeacherID(ctx)
	case homework.FieldExtra:
		return m.OldExtra(ctx)
	case homework.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case homework.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Homework field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HomeworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case homework.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case homework.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case homework.FieldPics:
		v, ok := value.([]model.Pic)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPics(v)
		return nil
	case homework.FieldClassID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case homework.FieldClassName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassName(v)
		return nil
	case homework.FieldTeacherID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeacherID(v)
		return nil
	case homework.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case homework.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case homework.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Homework field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HomeworkMutation) AddedFields() []string {
	var fields []string
	if m.addclass_id != nil {
		fields = append(fields, homework.FieldClassID)
	}
	if m.addteacher_id != nil {
		fields = append(fields, homework.FieldTeacherID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HomeworkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case homework.FieldClassID:
		return m.AddedClassID()
	case homework.FieldTeacherID:
		return m.AddedTeacherID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HomeworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case homework.FieldClassID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassID(v)
		return nil
	case homework.FieldTeacherID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeacherID(v)
		return nil
	}
	return fmt.Errorf("unknown Homework numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HomeworkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(homework.FieldTitle) {
		fields = append(fields, homework.FieldTitle)
	}
	if m.FieldCleared(homework.FieldContent) {
		fields = append(fields, homework.FieldContent)
	}
	if m.FieldCleared(homework.FieldPics) {
		fields = append(fields, homework.FieldPics)
	}
	if m.FieldCleared(homework.FieldClassID) {
		fields = append(fields, homework.FieldClassID)
	}
	if m.FieldCleared(homework.FieldClassName) {
		fields = append(fields, homework.FieldClassName)
	}
	if m.FieldCleared(homework.FieldTeacherID) {
		fields = append(fields, homework.FieldTeacherID)
	}
	if m.FieldCleared(homework.FieldExtra) {
		fields = append(fields, homework.FieldExtra)
	}
	if m.FieldCleared(homework.FieldCreatedAt) {
		fields = append(fields, homework.FieldCreatedAt)
	}
	if m.FieldCleared(homework.FieldUpdatedAt) {
		fields = append(fields, homework.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HomeworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HomeworkMutation) ClearField(name string) error {
	switch name {
	case homework.FieldTitle:
		m.ClearTitle()
		return nil
	case homework.FieldContent:
		m.ClearContent()
		return nil
	case homework.FieldPics:
		m.ClearPics()
		return nil
	case homework.FieldClassID:
		m.ClearClassID()
		return nil
	case homework.FieldClassName:
		m.ClearClassName()
		return nil
	case homework.FieldTeacherID:
		m.ClearTeacherID()
		return nil
	case homework.FieldExtra:
		m.ClearExtra()
		return nil
	case homework.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case homework.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Homework nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HomeworkMutation) ResetField(name string) error {
	switch name {
	case homework.FieldTitle:
		m.ResetTitle()
		return nil
	case homework.FieldContent:
		m.ResetContent()
		return nil
	case homework.FieldPics:
		m.ResetPics()
		return nil
	case homework.FieldClassID:
		m.ResetClassID()
		return nil
	case homework.FieldClassName:
		m.ResetClassName()
		return nil
	case homework.FieldTeacherID:
		m.ResetTeacherID()
		return nil
	case homework.FieldExtra:
		m.ResetExtra()
		return nil
	case homework.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case homework.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Homework field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HomeworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HomeworkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HomeworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HomeworkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HomeworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HomeworkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HomeworkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Homework unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HomeworkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Homework edge %s", name)
}

// NoticeMutation represents an operation that mutates the Notice nodes in the graph.
type NoticeMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	title         *string
	content       *string
	level         *uint8
	addlevel      *int8
	extra         *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notice, error)
	predicates    []predicate.Notice
}

var _ ent.Mutation = (*NoticeMutation)(nil)

// noticeOption allows management of the mutation configuration using functional options.
type noticeOption func(*NoticeMutation)

// newNoticeMutation creates new mutation for the Notice entity.
func newNoticeMutation(c config, op Op, opts ...noticeOption) *NoticeMutation {
	m := &NoticeMutation{
		config:        c,
		op:            op,
		typ:           TypeNotice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNoticeID sets the ID field of the mutation.
func withNoticeID(id uint64) noticeOption {
	return func(m *NoticeMutation) {
		var (
			err   error
			once  sync.Once
			value *Notice
		)
		m.oldValue = func(ctx context.Context) (*Notice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotice sets the old Notice of the mutation.
func withNotice(node *Notice) noticeOption {
	return func(m *NoticeMutation) {
		m.oldValue = func(context.Context) (*Notice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NoticeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NoticeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notice entities.
func (m *NoticeMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NoticeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NoticeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *NoticeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NoticeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *NoticeMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[notice.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *NoticeMutation) TitleCleared() bool {
	_, ok := m.clearedFields[notice.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *NoticeMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, notice.FieldTitle)
}

// SetContent sets the "content" field.
func (m *NoticeMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NoticeMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *NoticeMutation) ClearContent() {
	m.content = nil
	m.clearedFields[notice.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *NoticeMutation) ContentCleared() bool {
	_, ok := m.clearedFields[notice.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *NoticeMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, notice.FieldContent)
}

// SetLevel sets the "level" field.
func (m *NoticeMutation) SetLevel(u uint8) {
	m.level = &u
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *NoticeMutation) Level() (r uint8, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldLevel(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds u to the "level" field.
func (m *NoticeMutation) AddLevel(u int8) {
	if m.addlevel != nil {
		*m.addlevel += u
	} else {
		m.addlevel = &u
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *NoticeMutation) AddedLevel() (r int8, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *NoticeMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[notice.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *NoticeMutation) LevelCleared() bool {
	_, ok := m.clearedFields[notice.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *NoticeMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, notice.FieldLevel)
}

// SetExtra sets the "extra" field.
func (m *NoticeMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *NoticeMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *NoticeMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[notice.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *NoticeMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[notice.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *NoticeMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, notice.FieldExtra)
}

// SetCreatedAt sets the "created_at" field.
func (m *NoticeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NoticeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NoticeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[notice.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NoticeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[notice.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NoticeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, notice.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NoticeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NoticeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notice entity.
// If the Notice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoticeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NoticeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[notice.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NoticeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[notice.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NoticeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, notice.FieldUpdatedAt)
}

// Where appends a list predicates to the NoticeMutation builder.
func (m *NoticeMutation) Where(ps ...predicate.Notice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NoticeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Notice).
func (m *NoticeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NoticeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, notice.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, notice.FieldContent)
	}
	if m.level != nil {
		fields = append(fields, notice.FieldLevel)
	}
	if m.extra != nil {
		fields = append(fields, notice.FieldExtra)
	}
	if m.created_at != nil {
		fields = append(fields, notice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notice.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NoticeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notice.FieldTitle:
		return m.Title()
	case notice.FieldContent:
		return m.Content()
	case notice.FieldLevel:
		return m.Level()
	case notice.FieldExtra:
		return m.Extra()
	case notice.FieldCreatedAt:
		return m.CreatedAt()
	case notice.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NoticeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notice.FieldTitle:
		return m.OldTitle(ctx)
	case notice.FieldContent:
		return m.OldContent(ctx)
	case notice.FieldLevel:
		return m.OldLevel(ctx)
	case notice.FieldExtra:
		return m.OldExtra(ctx)
	case notice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoticeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notice.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notice.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case notice.FieldLevel:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case notice.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case notice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NoticeMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, notice.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NoticeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notice.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoticeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notice.FieldLevel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Notice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NoticeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notice.FieldTitle) {
		fields = append(fields, notice.FieldTitle)
	}
	if m.FieldCleared(notice.FieldContent) {
		fields = append(fields, notice.FieldContent)
	}
	if m.FieldCleared(notice.FieldLevel) {
		fields = append(fields, notice.FieldLevel)
	}
	if m.FieldCleared(notice.FieldExtra) {
		fields = append(fields, notice.FieldExtra)
	}
	if m.FieldCleared(notice.FieldCreatedAt) {
		fields = append(fields, notice.FieldCreatedAt)
	}
	if m.FieldCleared(notice.FieldUpdatedAt) {
		fields = append(fields, notice.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NoticeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NoticeMutation) ClearField(name string) error {
	switch name {
	case notice.FieldTitle:
		m.ClearTitle()
		return nil
	case notice.FieldContent:
		m.ClearContent()
		return nil
	case notice.FieldLevel:
		m.ClearLevel()
		return nil
	case notice.FieldExtra:
		m.ClearExtra()
		return nil
	case notice.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case notice.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NoticeMutation) ResetField(name string) error {
	switch name {
	case notice.FieldTitle:
		m.ResetTitle()
		return nil
	case notice.FieldContent:
		m.ResetContent()
		return nil
	case notice.FieldLevel:
		m.ResetLevel()
		return nil
	case notice.FieldExtra:
		m.ResetExtra()
		return nil
	case notice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Notice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NoticeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NoticeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NoticeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NoticeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NoticeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NoticeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NoticeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NoticeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notice edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	nickname      *string
	avatar        *string
	mobile        *string
	extra         *string
	class_id      *uint8
	addclass_id   *int8
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *UserMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[user.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *UserMutation) MobileCleared() bool {
	_, ok := m.clearedFields[user.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, user.FieldMobile)
}

// SetExtra sets the "extra" field.
func (m *UserMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *UserMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *UserMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[user.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *UserMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[user.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *UserMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, user.FieldExtra)
}

// SetClassID sets the "class_id" field.
func (m *UserMutation) SetClassID(u uint8) {
	m.class_id = &u
	m.addclass_id = nil
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *UserMutation) ClassID() (r uint8, exists bool) {
	v := m.class_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldClassID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// AddClassID adds u to the "class_id" field.
func (m *UserMutation) AddClassID(u int8) {
	if m.addclass_id != nil {
		*m.addclass_id += u
	} else {
		m.addclass_id = &u
	}
}

// AddedClassID returns the value that was added to the "class_id" field in this mutation.
func (m *UserMutation) AddedClassID() (r int8, exists bool) {
	v := m.addclass_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearClassID clears the value of the "class_id" field.
func (m *UserMutation) ClearClassID() {
	m.class_id = nil
	m.addclass_id = nil
	m.clearedFields[user.FieldClassID] = struct{}{}
}

// ClassIDCleared returns if the "class_id" field was cleared in this mutation.
func (m *UserMutation) ClassIDCleared() bool {
	_, ok := m.clearedFields[user.FieldClassID]
	return ok
}

// ResetClassID resets all changes to the "class_id" field.
func (m *UserMutation) ResetClassID() {
	m.class_id = nil
	m.addclass_id = nil
	delete(m.clearedFields, user.FieldClassID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.extra != nil {
		fields = append(fields, user.FieldExtra)
	}
	if m.class_id != nil {
		fields = append(fields, user.FieldClassID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldExtra:
		return m.Extra()
	case user.FieldClassID:
		return m.ClassID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldExtra:
		return m.OldExtra(ctx)
	case user.FieldClassID:
		return m.OldClassID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case user.FieldClassID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addclass_id != nil {
		fields = append(fields, user.FieldClassID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldClassID:
		return m.AddedClassID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldClassID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldMobile) {
		fields = append(fields, user.FieldMobile)
	}
	if m.FieldCleared(user.FieldExtra) {
		fields = append(fields, user.FieldExtra)
	}
	if m.FieldCleared(user.FieldClassID) {
		fields = append(fields, user.FieldClassID)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldMobile:
		m.ClearMobile()
		return nil
	case user.FieldExtra:
		m.ClearExtra()
		return nil
	case user.FieldClassID:
		m.ClearClassID()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldExtra:
		m.ResetExtra()
		return nil
	case user.FieldClassID:
		m.ResetClassID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserHomeWorkMutation represents an operation that mutates the UserHomeWork nodes in the graph.
type UserHomeWorkMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	homework_id    *uint64
	addhomework_id *int64
	user_id        *uint64
	adduser_id     *int64
	title          *string
	content        *string
	pics           *[]model.Pic
	extra          *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*UserHomeWork, error)
	predicates     []predicate.UserHomeWork
}

var _ ent.Mutation = (*UserHomeWorkMutation)(nil)

// userhomeworkOption allows management of the mutation configuration using functional options.
type userhomeworkOption func(*UserHomeWorkMutation)

// newUserHomeWorkMutation creates new mutation for the UserHomeWork entity.
func newUserHomeWorkMutation(c config, op Op, opts ...userhomeworkOption) *UserHomeWorkMutation {
	m := &UserHomeWorkMutation{
		config:        c,
		op:            op,
		typ:           TypeUserHomeWork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserHomeWorkID sets the ID field of the mutation.
func withUserHomeWorkID(id uint64) userhomeworkOption {
	return func(m *UserHomeWorkMutation) {
		var (
			err   error
			once  sync.Once
			value *UserHomeWork
		)
		m.oldValue = func(ctx context.Context) (*UserHomeWork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserHomeWork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserHomeWork sets the old UserHomeWork of the mutation.
func withUserHomeWork(node *UserHomeWork) userhomeworkOption {
	return func(m *UserHomeWorkMutation) {
		m.oldValue = func(context.Context) (*UserHomeWork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserHomeWorkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserHomeWorkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserHomeWork entities.
func (m *UserHomeWorkMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserHomeWorkMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserHomeWorkMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserHomeWork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHomeworkID sets the "homework_id" field.
func (m *UserHomeWorkMutation) SetHomeworkID(u uint64) {
	m.homework_id = &u
	m.addhomework_id = nil
}

// HomeworkID returns the value of the "homework_id" field in the mutation.
func (m *UserHomeWorkMutation) HomeworkID() (r uint64, exists bool) {
	v := m.homework_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeworkID returns the old "homework_id" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldHomeworkID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeworkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeworkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeworkID: %w", err)
	}
	return oldValue.HomeworkID, nil
}

// AddHomeworkID adds u to the "homework_id" field.
func (m *UserHomeWorkMutation) AddHomeworkID(u int64) {
	if m.addhomework_id != nil {
		*m.addhomework_id += u
	} else {
		m.addhomework_id = &u
	}
}

// AddedHomeworkID returns the value that was added to the "homework_id" field in this mutation.
func (m *UserHomeWorkMutation) AddedHomeworkID() (r int64, exists bool) {
	v := m.addhomework_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearHomeworkID clears the value of the "homework_id" field.
func (m *UserHomeWorkMutation) ClearHomeworkID() {
	m.homework_id = nil
	m.addhomework_id = nil
	m.clearedFields[userhomework.FieldHomeworkID] = struct{}{}
}

// HomeworkIDCleared returns if the "homework_id" field was cleared in this mutation.
func (m *UserHomeWorkMutation) HomeworkIDCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldHomeworkID]
	return ok
}

// ResetHomeworkID resets all changes to the "homework_id" field.
func (m *UserHomeWorkMutation) ResetHomeworkID() {
	m.homework_id = nil
	m.addhomework_id = nil
	delete(m.clearedFields, userhomework.FieldHomeworkID)
}

// SetUserID sets the "user_id" field.
func (m *UserHomeWorkMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserHomeWorkMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *UserHomeWorkMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserHomeWorkMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserHomeWorkMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[userhomework.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserHomeWorkMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserHomeWorkMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, userhomework.FieldUserID)
}

// SetTitle sets the "title" field.
func (m *UserHomeWorkMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UserHomeWorkMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *UserHomeWorkMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[userhomework.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *UserHomeWorkMutation) TitleCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *UserHomeWorkMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, userhomework.FieldTitle)
}

// SetContent sets the "content" field.
func (m *UserHomeWorkMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *UserHomeWorkMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *UserHomeWorkMutation) ClearContent() {
	m.content = nil
	m.clearedFields[userhomework.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *UserHomeWorkMutation) ContentCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *UserHomeWorkMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, userhomework.FieldContent)
}

// SetPics sets the "pics" field.
func (m *UserHomeWorkMutation) SetPics(value []model.Pic) {
	m.pics = &value
}

// Pics returns the value of the "pics" field in the mutation.
func (m *UserHomeWorkMutation) Pics() (r []model.Pic, exists bool) {
	v := m.pics
	if v == nil {
		return
	}
	return *v, true
}

// OldPics returns the old "pics" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldPics(ctx context.Context) (v []model.Pic, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPics: %w", err)
	}
	return oldValue.Pics, nil
}

// ClearPics clears the value of the "pics" field.
func (m *UserHomeWorkMutation) ClearPics() {
	m.pics = nil
	m.clearedFields[userhomework.FieldPics] = struct{}{}
}

// PicsCleared returns if the "pics" field was cleared in this mutation.
func (m *UserHomeWorkMutation) PicsCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldPics]
	return ok
}

// ResetPics resets all changes to the "pics" field.
func (m *UserHomeWorkMutation) ResetPics() {
	m.pics = nil
	delete(m.clearedFields, userhomework.FieldPics)
}

// SetExtra sets the "extra" field.
func (m *UserHomeWorkMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *UserHomeWorkMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldExtra(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *UserHomeWorkMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[userhomework.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *UserHomeWorkMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *UserHomeWorkMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, userhomework.FieldExtra)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserHomeWorkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserHomeWorkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserHomeWorkMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userhomework.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserHomeWorkMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserHomeWorkMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userhomework.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserHomeWorkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserHomeWorkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserHomeWork entity.
// If the UserHomeWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHomeWorkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserHomeWorkMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userhomework.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserHomeWorkMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userhomework.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserHomeWorkMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userhomework.FieldUpdatedAt)
}

// Where appends a list predicates to the UserHomeWorkMutation builder.
func (m *UserHomeWorkMutation) Where(ps ...predicate.UserHomeWork) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserHomeWorkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserHomeWork).
func (m *UserHomeWorkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserHomeWorkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.homework_id != nil {
		fields = append(fields, userhomework.FieldHomeworkID)
	}
	if m.user_id != nil {
		fields = append(fields, userhomework.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, userhomework.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, userhomework.FieldContent)
	}
	if m.pics != nil {
		fields = append(fields, userhomework.FieldPics)
	}
	if m.extra != nil {
		fields = append(fields, userhomework.FieldExtra)
	}
	if m.created_at != nil {
		fields = append(fields, userhomework.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userhomework.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserHomeWorkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userhomework.FieldHomeworkID:
		return m.HomeworkID()
	case userhomework.FieldUserID:
		return m.UserID()
	case userhomework.FieldTitle:
		return m.Title()
	case userhomework.FieldContent:
		return m.Content()
	case userhomework.FieldPics:
		return m.Pics()
	case userhomework.FieldExtra:
		return m.Extra()
	case userhomework.FieldCreatedAt:
		return m.CreatedAt()
	case userhomework.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserHomeWorkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userhomework.FieldHomeworkID:
		return m.OldHomeworkID(ctx)
	case userhomework.FieldUserID:
		return m.OldUserID(ctx)
	case userhomework.FieldTitle:
		return m.OldTitle(ctx)
	case userhomework.FieldContent:
		return m.OldContent(ctx)
	case userhomework.FieldPics:
		return m.OldPics(ctx)
	case userhomework.FieldExtra:
		return m.OldExtra(ctx)
	case userhomework.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userhomework.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserHomeWork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHomeWorkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userhomework.FieldHomeworkID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeworkID(v)
		return nil
	case userhomework.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userhomework.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case userhomework.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case userhomework.FieldPics:
		v, ok := value.([]model.Pic)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPics(v)
		return nil
	case userhomework.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case userhomework.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userhomework.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserHomeWork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserHomeWorkMutation) AddedFields() []string {
	var fields []string
	if m.addhomework_id != nil {
		fields = append(fields, userhomework.FieldHomeworkID)
	}
	if m.adduser_id != nil {
		fields = append(fields, userhomework.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserHomeWorkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userhomework.FieldHomeworkID:
		return m.AddedHomeworkID()
	case userhomework.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHomeWorkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userhomework.FieldHomeworkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeworkID(v)
		return nil
	case userhomework.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserHomeWork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserHomeWorkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userhomework.FieldHomeworkID) {
		fields = append(fields, userhomework.FieldHomeworkID)
	}
	if m.FieldCleared(userhomework.FieldUserID) {
		fields = append(fields, userhomework.FieldUserID)
	}
	if m.FieldCleared(userhomework.FieldTitle) {
		fields = append(fields, userhomework.FieldTitle)
	}
	if m.FieldCleared(userhomework.FieldContent) {
		fields = append(fields, userhomework.FieldContent)
	}
	if m.FieldCleared(userhomework.FieldPics) {
		fields = append(fields, userhomework.FieldPics)
	}
	if m.FieldCleared(userhomework.FieldExtra) {
		fields = append(fields, userhomework.FieldExtra)
	}
	if m.FieldCleared(userhomework.FieldCreatedAt) {
		fields = append(fields, userhomework.FieldCreatedAt)
	}
	if m.FieldCleared(userhomework.FieldUpdatedAt) {
		fields = append(fields, userhomework.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserHomeWorkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserHomeWorkMutation) ClearField(name string) error {
	switch name {
	case userhomework.FieldHomeworkID:
		m.ClearHomeworkID()
		return nil
	case userhomework.FieldUserID:
		m.ClearUserID()
		return nil
	case userhomework.FieldTitle:
		m.ClearTitle()
		return nil
	case userhomework.FieldContent:
		m.ClearContent()
		return nil
	case userhomework.FieldPics:
		m.ClearPics()
		return nil
	case userhomework.FieldExtra:
		m.ClearExtra()
		return nil
	case userhomework.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userhomework.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserHomeWork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserHomeWorkMutation) ResetField(name string) error {
	switch name {
	case userhomework.FieldHomeworkID:
		m.ResetHomeworkID()
		return nil
	case userhomework.FieldUserID:
		m.ResetUserID()
		return nil
	case userhomework.FieldTitle:
		m.ResetTitle()
		return nil
	case userhomework.FieldContent:
		m.ResetContent()
		return nil
	case userhomework.FieldPics:
		m.ResetPics()
		return nil
	case userhomework.FieldExtra:
		m.ResetExtra()
		return nil
	case userhomework.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userhomework.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserHomeWork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserHomeWorkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserHomeWorkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserHomeWorkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserHomeWorkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserHomeWorkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserHomeWorkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserHomeWorkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserHomeWork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserHomeWorkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserHomeWork edge %s", name)
}
